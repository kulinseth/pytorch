//  Copyright Â© 2022 Apple Inc.

#pragma once

#include <ATen/Tensor.h>
#include <ATen/mps/MPSStream.h>
#include <ATen/mps/MPSAllocatorInterface.h>
#include <fmt/format.h>

#include <os/signpost.h>
#include <os/log.h>

#include <sstream>
#include <string>
#include <unordered_map>
#include <utility>

namespace at::mps {

namespace Profiler {

struct BaseInfo {
  // profiling info types
  enum class Type {
    GRAPH,
    KERNEL,
    COPY,
  };

  BaseInfo(Type infoType, uint32_t Id, const void* Handle) :
      type(infoType), id(Id), handle(Handle) { }
  virtual ~BaseInfo() = default;

  // type of profiling info
  Type type;
  // unique id for graphs or kernels
  uint32_t id;
  // ID generated by os_signpost
  uint64_t signpostId = 0;
  // accumulated GPU time
  double totalGpuTime = 0.0;
  // handle used to identify the profile info's instance
  const void* handle;

  virtual const std::string toString(double gpuTime = 0, double kernelTime = 0) const {
    // the gpuTime will be non-zero mainly for event-based signposts.
    // The interval-based signposts will have "duration" as well as accumulated
    // total GPU time, up to the point of execution.
    return gpuTime > 0.0 ? fmt::format(", GPU={:.3f} ms, KRNL={:.3f} ms", gpuTime, kernelTime) : "";
  }

  // builds a string for a tensor (format: Device:ScalarType[tensor.sizes()])
  static std::string buildTensorString(const Tensor& tensor) {
    if (tensor.defined()) {
      std::stringstream tensorStr;
      tensorStr << c10::DeviceTypeName(tensor.device().type()) << ":"
                << tensor.scalar_type() << tensor.sizes();
      return tensorStr.str();
    } else {
      return "undefined";
    }
  }
};

struct KernelInfo : BaseInfo {
  KernelInfo(const void* Handle, bool IsGraph, uint32_t Id, const std::string& StrKey) :
      BaseInfo(IsGraph ? Type::GRAPH : Type::KERNEL, Id, Handle), strKey(StrKey) { }
   ~KernelInfo() override = default;

  uint64_t runCount = 0;
  std::string strKey;

  const std::string toString(double gpuTime = 0, double kernelTime = 0) const override {
    return fmt::format("{} #{} [Run#={}{}]: {}",
                       type == Type::GRAPH ? "Graph" : "Kernel", id, runCount,
                       BaseInfo::toString(gpuTime, kernelTime), strKey);
  }

  // builds a string for a kernel
  static std::string buildKernelString(const std::string& kernelName, const TensorList& tensors) {
    std::stringstream kernelStr;
    kernelStr << kernelName;
    for (const Tensor& tensor: tensors) {
      kernelStr << ":" << BaseInfo::buildTensorString(tensor);
    }
    return kernelStr.str();
  }
};

struct CopyInfo : BaseInfo {
  CopyInfo(const void* Handle, size_t Length,  uint32_t Id, bool IsNonBlocking) :
      BaseInfo(Type::COPY, Id, Handle), length(Length), isNonBlocking(IsNonBlocking) { }
  ~CopyInfo() override = default;

  size_t length;
  bool isNonBlocking;
  std::string srcStrKey;
  std::string dstStrKey;

  const std::string toString(double gpuTime = 0, double kernelTime = 0) const override {
    return fmt::format("Copy{} #{} [Len={}{}]: {} -> {}",
                       // CopySync indicates COMMIT_AND_WAIT was used to synchronize
                       // the GPU stream with CPU after the blocking copy
                       isNonBlocking ? "" : "Sync", id,
                       getIMPSAllocator()->formatSize(length),
                       BaseInfo::toString(gpuTime, kernelTime), srcStrKey, dstStrKey);
  }

  static std::string buildTensorString(const void* buffer, const OptionalTensorRef tensor) {
    if (tensor.has_value()) {
      return BaseInfo::buildTensorString(*tensor);
    }
    // if tensor is not defined (e.g., copy_blit_mps()), then use buffer
    // pointer to build the string.
    // getUnalignedBufferSize() returns -1 if input buffer is not on MPS device
    const bool isSrcOnMPS = getIMPSAllocator()->getUnalignedBufferSize((void*)buffer) >= 0;
    return fmt::format("{}:{:p}", isSrcOnMPS ? "MPS" : "CPU", buffer);
  }
};

} // namespace Profiler

class MPSProfiler {
public:
  // lower 16 bits used for profiler options
  enum ProfileOptions : uint32_t {
    OPTIONS_NONE = 0,
    // ALL_* means, all signpost types (RUN_MPSGRAPH|RUN_KERNEL|BLIT_COPY, etc.)
    // (used for convenience to not compute bit flags by OR-ing manually)
    // trace all signpost types using events
    ALL_SIGNPOST_EVENTS    = (1 << 0),
    // trace all signpost types using intervals
    ALL_SIGNPOST_INTERVALS = (1 << 1),
    // always wait for command buffer to finish executing after each commit
    WAIT_UNTIL_COMPLETED   = (1 << 2),

    // use these if you need to trace signposts types individually
    // trace signpost using intervals
    USE_INTERVALS = (1 << 3),
    // trace signpost by emitting events
    USE_EVENTS    = (1 << 4),
    // used for sanity check (Change this when new option added)
    OPTIONS_COUNT = (USE_EVENTS << 1) - 1,
  };

  // when adding new types, #define the type string in MPSProfiler.mm as well.
  // upper 16 bits used for event types
  enum SignpostTypes : uint32_t {
    SIGNPOST_NONE = 0,
    // trace signposts for MPSGraph executions
    RUN_MPSGRAPH   = (1 << 16),
    // trace signposts for native kernel executions
    RUN_KERNEL     = (1 << 17),
    // trace signposts for blitter copies
    BLIT_COPY      = (1 << 18),
    // used for sanity check (Change this when new type added)
    SIGNPOST_COUNT = (BLIT_COPY << 1) - 1,
  };

  enum LogOptions : uint32_t {
    LOG_NONE = 0,
    // prints graph or native kernel info (id/key/run_count) before execution
    KERNEL_INFO      = (1 << 0),
    // prints copy info (src/dst tensors/buffers, size, etc.)
    BLIT_COPY_INFO   = (1 << 1),
    // prints accumulated GPU times for kernels before process terminates
    KERNEL_PROFILING = (1 << 2),
    // prints memory allocation info from MPSAllocator
    // TODO: move all the logging from MPSAllocator to MPSProfiler
    MPS_ALLOCATOR    = (1 << 3),
    // used for sanity check (Change this when new option added)
    LOG_COUNT = (MPS_ALLOCATOR << 1) - 1,
  };

  explicit MPSProfiler();
  ~MPSProfiler();

  // the handle is either "MPSGraph*" or "id<MTLComputePipelineState>" for Metal Kernels
  void beginProfileKernel(const void* handle, const std::string& strKey, bool isGraph);
  void beginProfileKernel(const void* handle, const std::string& kernelName, const TensorList& tensors);
  void endProfileKernel(const void* handle);

  // the handle is dstBuffer's pointer based on the fact that only one copy
  // could be done into a dstBuffer at any point in time
  void beginProfileCopy(const void* srcBuffer, const void* dstBuffer,
                        const OptionalTensorRef srcTensor,
                        const OptionalTensorRef dstTensor,
                        size_t length, bool isNonBlocking);
  void endProfileCopy(const void* handle);

  // convenience functions to indicate whether signpost tracing or
  // logging are enabled for the SignpostTypes
  bool isGraphProfilingEnabled() const {
    return (m_signpost_types & SignpostTypes::RUN_MPSGRAPH) ||
           (m_log_options & (LogOptions::KERNEL_INFO | LogOptions::KERNEL_PROFILING));
  }
  bool isKernelProfilingEnabled() const {
    return (m_signpost_types & SignpostTypes::RUN_KERNEL) ||
           (m_log_options & (LogOptions::KERNEL_INFO | LogOptions::KERNEL_PROFILING));
  }
  bool isCopyProfilingEnabled() const {
    return (m_signpost_types & SignpostTypes::BLIT_COPY) ||
           (m_log_options & LogOptions::BLIT_COPY_INFO);
  }

  uint32_t getSignpostTypes() const { return m_signpost_types; }
  uint32_t getProfileOptions() const { return m_profile_options; }
  uint32_t getLogOptions() const { return m_log_options; }

 private:
  // indicates what type of signpost types are enabled and traced by MPS profiler.
  uint32_t m_signpost_types = 0;
  uint32_t m_profile_options = 0;
  uint32_t m_log_options = 0;
  uint32_t m_kernel_counter = 0;
  uint32_t m_graph_counter = 0;
  uint32_t m_copy_counter = 0;
  size_t   m_total_copy_size = 0;
  // technically, it's possible to trace both events and intervals at the same time
  // so we use separate os_log categories for them
  os_log_t m_os_log_events;
  os_log_t m_os_log_intervals;
  // used to synchronize with the completion handler
  std::mutex m_mutex;

  // We use the following lists for two reasons:
  // 1- for interval-based signposts the "begin" point won't be in same function
  // as the "end" point where we need to be able to retrieve signpost's info
  // 2- if Graph/Kernel info need to be logged when process ends using LogOptions::KERNEL_INFO.

  // the pointer key for this map is either "MPSGraph*" or "id<MTLComputePipelineState>" for Metal Kernels
  // this list is retained and could be logged along with aggregate profiling numbers when the process ends.
  std::unordered_map<const void*, std::unique_ptr<Profiler::KernelInfo>> m_kernel_info_list{};
  // this list contains the info for copies, and its key is the destination buffer pointer.
  // The copyInfo list is not retained.
  std::unordered_map<const void*, std::unique_ptr<Profiler::CopyInfo>> m_copy_info_list{};

  void addProfilerCompletedHandler(Profiler::BaseInfo* info, SignpostTypes signpostType, SyncType syncType);
  uint64_t emitSignpostEvent(SignpostTypes signpost_type, const std::string& msg) const;
  uint64_t beginSignpostInterval(SignpostTypes signpost_type, const std::string& msg) const;
  void endSignpostInterval(SignpostTypes signpost_type, os_signpost_id_t signpost_id) const;
  // logs kernel profiling results when the process ends.
  void logKernelProfiling(std::FILE* f) const;
  // TODO: add support for logging copy profiling results when the process ends.
};

MPSProfiler& getMPSProfiler();

} // namespace at::mps