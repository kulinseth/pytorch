//  Copyright Â© 2022 Apple Inc.

#pragma once

#include <ATen/Tensor.h>
#include <ATen/mps/MPSStream.h>
#include <ATen/mps/MPSAllocatorInterface.h>
#include <fmt/format.h>

#include <os/signpost.h>
#include <os/log.h>

#include <sstream>
#include <string>
#include <atomic>
#include <unordered_map>
#include <utility>

namespace at::mps {

namespace Profiler {

struct BaseInfo {
  // profiling info types
  enum class Type {
    GRAPH,
    KERNEL,
    COPY,
  };

  BaseInfo(Type infoType, uint64_t Id, const uintptr_t Handle) :
      type(infoType), profileId(Id), handle(Handle) { }
  virtual ~BaseInfo() = default;

  // type of profiling info
  Type type;
  // unique profile ID for execution instances of graphs/kernels/copies
  uint64_t profileId;
  // ID generated by os_signpost
  // since it's possible to use event and interval-based signposts at the
  // same time, we need separate IDs for each.
  os_signpost_id_t eventSignpostId = 0, intervalSignpostId = 0;
  // accumulated GPU time
  std::atomic<double> totalGpuTime{0.0};
  // accumulated Kernel time
  std::atomic<double> totalKernelTime{0.0};
  // indicates if the graph/kernel or copy execution has completed
  std::atomic_bool completed{false};
  // handle used to identify the profile info's instance (usually the pointer)
  const uintptr_t handle;

  virtual const std::string toString(double gpuTime = 0, double kernelTime = 0) const {
    // the gpuTime will be non-zero mainly for event-based signposts.
    // The interval-based signposts will have "duration" as well as accumulated
    // total GPU time, up to the point of execution.
    return gpuTime > 0.0 ? fmt::format(", GPU={:.3f} ms, KRNL={:.3f} ms", gpuTime, kernelTime) : "";
  }

  // builds a string for a tensor (format: Device:ScalarType[tensor.sizes()])
  static std::string buildTensorString(const Tensor& tensor) {
    if (tensor.defined()) {
      std::stringstream tensorStr;
      tensorStr << c10::DeviceTypeName(tensor.device().type()) << ":"
                << tensor.scalar_type() << tensor.sizes();
      return tensorStr.str();
    } else {
      return "undefined";
    }
  }
};

struct KernelInfo : BaseInfo {
  KernelInfo(const void* Handle, bool IsGraph, uint64_t Id, const std::string& StrKey) :
      BaseInfo(IsGraph ? Type::GRAPH : Type::KERNEL, Id, uintptr_t(Handle)), strKey(StrKey) { }
  ~KernelInfo() override = default;

  uint64_t runCount = 0;
  std::string strKey;

  const std::string toString(double gpuTime = 0, double kernelTime = 0) const override {
    return fmt::format("{} #{} [Run#={}{}]: {}",
                       type == Type::GRAPH ? "Graph" : "Kernel", profileId, runCount,
                       BaseInfo::toString(gpuTime, kernelTime), strKey);
  }

  // builds a string for a kernel
  static std::string buildKernelString(const std::string& kernelName, const TensorList& tensors) {
    std::stringstream kernelStr;
    kernelStr << kernelName;
    for (const Tensor& tensor: tensors) {
      kernelStr << ":" << BaseInfo::buildTensorString(tensor);
    }
    return kernelStr.str();
  }
};

struct CopyInfo : BaseInfo {
  enum class Kind {
    MPS_TO_MPS,
    MPS_TO_CPU,
    CPU_TO_MPS,
  };

  CopyInfo(const void* Handle, size_t Length, uint64_t Id, bool IsNonBlocking) :
           BaseInfo(Type::COPY, Id, uintptr_t(Handle)), kind(Kind::MPS_TO_MPS),
           length(Length), isNonBlocking(IsNonBlocking) { }
  ~CopyInfo() override = default;

  Kind kind;
  size_t length;
  bool isNonBlocking;
  std::string srcStrKey;
  std::string dstStrKey;

  const std::string toString(double gpuTime = 0, double kernelTime = 0) const override {
    return fmt::format("Copy{} #{} [Len={}{}]: {} -> {}",
                       // CopySync indicates COMMIT_AND_WAIT was used to synchronize
                       // the GPU stream with CPU after the blocking copy
                       isNonBlocking ? "" : "Sync", profileId,
                       getIMPSAllocator()->formatSize(length),
                       BaseInfo::toString(gpuTime, kernelTime), srcStrKey, dstStrKey);
  }

  static std::string buildTensorString(const void* buffer, const OptionalTensorRef tensor) {
    if (tensor.has_value()) {
      return BaseInfo::buildTensorString(*tensor);
    }
    // if tensor is not defined (e.g., copy_blit_mps()), then use buffer
    // pointer to build the string.
    const bool isBufferOnMPS = isStorageOnMPS(buffer, tensor);
    return fmt::format("{}:{:p}", isBufferOnMPS ? "MPS" : "CPU", buffer);
  }

  static bool isStorageOnMPS(const void* buffer, const OptionalTensorRef tensor) {
    if (tensor.has_value()) {
      return tensor->device().type() == at::kMPS;
    }
    TORCH_INTERNAL_ASSERT_DEBUG_ONLY(buffer);
    // getUnalignedBufferSize() returns -1 if input buffer is not on MPS device
    return getIMPSAllocator()->getUnalignedBufferSize((void*)buffer) >= 0;
  }

  static Kind getCopyKind(const void* srcBuffer, const void* dstBuffer,
                          const OptionalTensorRef srcTensor, const OptionalTensorRef dstTensor) {
    const bool isSrcOnMPS = isStorageOnMPS(srcBuffer, srcTensor);
    const bool isDstOnMPS = isStorageOnMPS(dstBuffer, dstTensor);
    TORCH_INTERNAL_ASSERT_DEBUG_ONLY(isSrcOnMPS || isDstOnMPS);
    if (isSrcOnMPS && !isDstOnMPS) {
      return Kind::MPS_TO_CPU;
    } else if (!isSrcOnMPS && isDstOnMPS) {
      return Kind::CPU_TO_MPS;
    }
    return Kind::MPS_TO_MPS;
  }
};

struct CopyStat : CopyInfo {
  explicit CopyStat(std::string CopyKindStr) : CopyInfo(nullptr, 0, 0, false), kindStr(std::move(CopyKindStr)) {}
  // total number of copies
  size_t totalCount = 0;
  // number of Scalar copies (i.e., less than sizeof(int64))
  size_t scalarsCount = 0;
  // accumulated GPU time for the scalar copies
  std::atomic<double> scalarsGpuTime{0.0};
  // copy kind in string type
  std::string kindStr;
};

} // namespace Profiler

class MPSProfiler {
public:
  // lower 16 bits used for profiler options
  enum ProfileOptions : uint32_t {
    OPTIONS_NONE = 0,
    // ALL_* means, all signpost types (RUN_MPSGRAPH|RUN_KERNEL|BLIT_COPY, etc.)
    // (used for convenience to not compute bit flags by OR-ing manually)
    // trace all signpost types using events
    ALL_SIGNPOST_EVENTS    = (1 << 0),
    // trace all signpost types using intervals
    ALL_SIGNPOST_INTERVALS = (1 << 1),
    // always wait for command buffer to finish executing after each commit
    WAIT_UNTIL_COMPLETED   = (1 << 2),
    // for interval-based signposts, include the scheduling portion of
    // Graph/Kernel/Copy executions as well.
    // if flag is disable, only "GPU run time" is included in interval,
    // and not schedule time.
    INCLUDE_SCHEDULE_INTERVAL = (1 << 3),

    // use these if you need to trace signposts types individually (rarely required)
    // trace signpost using intervals
    USE_INTERVALS = (1 << 4),
    // trace signpost by emitting events
    USE_EVENTS    = (1 << 5),
    // used for sanity check (Change this when new option added)
    OPTIONS_COUNT = (USE_EVENTS << 1) - 1,
  };

  // when adding new types, #define the type string in MPSProfiler.mm as well.
  // upper 16 bits used for event types
  enum SignpostTypes : uint32_t {
    SIGNPOST_NONE = 0,
    // trace signposts for MPSGraph executions
    RUN_MPSGRAPH = (1 << 16),
    // trace signposts for native kernel executions
    RUN_KERNEL   = (1 << 17),
    // trace signposts for blitter copies
    BLIT_COPY    = (1 << 18),
    // used for sanity check (Change this when new type added)
    SIGNPOST_COUNT = (BLIT_COPY << 1) - 1,
  };

  enum LogOptions : uint32_t {
    LOG_NONE = 0,
    // prints graph or native kernel info (id/key/run_count) before execution
    KERNEL_INFO  = (1 << 0),
    // prints copy info (src/dst tensors/buffers, size, etc.)
    COPY_INFO    = (1 << 1),
    // prints kernels stats (GPU times, run count, etc.) before process terminates
    KERNEL_STATS = (1 << 2),
    // prints copies stats (GPU times, copy kinds, sizes, etc.) before process terminates
    COPY_STATS   = (1 << 3),
    // used for sanity check (Change this when new option added)
    LOG_COUNT = (COPY_STATS << 1) - 1,
  };

  explicit MPSProfiler();
  ~MPSProfiler();

  // the handle is either "MPSGraph*" or "id<MTLComputePipelineState>" for Metal Kernels
  // the beginProfile*() functions return a profileId which is unique per graph/kernel/copy
  uint64_t beginProfileKernel(const void* handle, const std::string& strKey, bool isGraph);
  uint64_t beginProfileKernel(const void* handle, const std::string& kernelName, const TensorList& tensors);
  uint64_t beginProfileCopy(const void* srcBuffer, const void* dstBuffer,
                            const OptionalTensorRef srcTensor,
                            const OptionalTensorRef dstTensor,
                            size_t length, bool isNonBlocking);

  void beginProfileGPUInterval(const void* handle);
  void endProfileCopy(uint64_t profileId, SyncType syncType);
  void endProfileKernel(const void* handle, SyncType syncType = SyncType::NONE);

  // convenience functions to indicate whether signpost tracing or
  // logging are enabled for the SignpostTypes
  bool isGraphProfilingEnabled() const {
    return (m_signpost_types & SignpostTypes::RUN_MPSGRAPH) ||
           (m_log_options & (LogOptions::KERNEL_INFO | LogOptions::KERNEL_STATS));
  }
  bool isKernelProfilingEnabled() const {
    return (m_signpost_types & SignpostTypes::RUN_KERNEL) ||
           (m_log_options & (LogOptions::KERNEL_INFO | LogOptions::KERNEL_STATS));
  }
  bool isCopyProfilingEnabled() const {
    return (m_signpost_types & SignpostTypes::BLIT_COPY) ||
           (m_log_options & (LogOptions::COPY_INFO | LogOptions::COPY_STATS));
  }

  uint32_t getSignpostTypes() const { return m_signpost_types; }
  uint32_t getProfileOptions() const { return m_profile_options; }
  uint32_t getLogOptions() const { return m_log_options; }

 private:
  // indicates what type of signpost types are enabled and traced by MPS profiler.
  uint32_t m_signpost_types = 0;
  uint32_t m_profile_options = 0;
  uint32_t m_log_options = 0;
  uint64_t m_kernel_counter = 0;
  uint64_t m_graph_counter = 0;
  uint64_t m_copy_counter = 0;
  // technically, it's possible to trace both events and intervals at the same time
  // so we use separate os_log categories for them
  os_log_t m_os_log_events;
  os_log_t m_os_log_intervals;

  // We use the following lists for two reasons:
  // 1- for interval-based signposts the "begin" point won't be in same function
  // as the "end" point where we need to be able to retrieve signpost's info
  // 2- if Graph/Kernel info need to be logged when process ends using LogOptions::KERNEL_INFO.

  // the pointer key for this map is either "MPSGraph*" or "id<MTLComputePipelineState>" for Metal Kernels
  // this list is retained and could be logged along with aggregate profiling numbers when the process ends.
  std::unordered_map<uintptr_t, std::unique_ptr<Profiler::KernelInfo>> m_kernel_info_list{};
  // this list contains the info for copies, and its key is the unique profileId
  // which is generated from m_copy_counter
  // The copyInfo list is not retained.
  std::unordered_map<uint64_t, std::unique_ptr<Profiler::CopyInfo>> m_copy_info_list{};
  // a short list that contains copy stats
  std::unordered_map<Profiler::CopyInfo::Kind, std::unique_ptr<Profiler::CopyStat>> m_copy_stat_list{};

  void beginProfileExecution(Profiler::BaseInfo& info);
  void addProfilerScheduledHandler(Profiler::BaseInfo& info);
  void addProfilerCompletedHandler(Profiler::BaseInfo& info, SyncType syncType);
  void emitSignpostEvent(SignpostTypes signpost_type, os_signpost_id_t signpost_id,
                         const std::string& msg) const;
  void beginSignpostInterval(SignpostTypes signpost_type, os_signpost_id_t signpost_id,
                             const std::string& msg) const;
  void endSignpostInterval(SignpostTypes signpost_type, os_signpost_id_t signpost_id) const;

  // logs kernel profiling stats when the process ends.
  void logKernelProfilingStats(std::FILE* f) const;
  // logs copy profiling stats when the process ends.
  void logCopyProfilingStats(std::FILE* f);

  os_signpost_id_t generateSignpostId(os_signpost_type_t signpostType, const void* ptr = nullptr);
  static SignpostTypes getSignpostType(Profiler::BaseInfo::Type infoType);
};

MPSProfiler& getMPSProfiler();

} // namespace at::mps
